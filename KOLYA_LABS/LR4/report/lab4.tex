\documentclass[a4paper, 14pt]{article}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{listings}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
    decorations.pathreplacing,decorations.pathmorphing,shapes,%
    matrix,shapes.symbols}

\usepackage{titlesec}
\titleformat*{\section}{\LARGE\bfseries\centering}
\titleformat*{\subsection}{\Large\bfseries\centering}
\titleformat*{\subsubsection}{\large\bfseries}
\titleformat*{\paragraph}{\large\bfseries}
\titleformat*{\subparagraph}{\large\bfseries}
\lstset{ %
language=python,                 % выбор языка для подсветки (здесь это С)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\#*}{*)}   % если нужно добавить комментарии в коде
}

\usepackage{geometry}
\geometry{left=2cm}
\geometry{right=1.5cm}
\geometry{top=1cm}
\geometry{bottom=2cm}

\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}
\usepackage{graphicx}

\begin{document}

    \begin{titlepage}

        \begin{center}
            \large
            Государственное образовательное учреждение высшего профессионального образования\\
            “Московский государственный технический университет имени Н.Э.Баумана”
            \vspace{3cm}
            
            \textsc{Дисциплина: Анализ алгоритмов}
            \vspace{0.5cm}
                
            \textsc{Лабораторная работа 4}
            \vspace{1.5cm}
            
            {\LARGE Умножение матриц с помощью алгоритма Винограда c параллельными вычислениями.\\}
            \vspace{1.5cm}
            Студент группы ИУ7-55,\\   
            Шестовских Николай Александрович\\
            Преподаватели: Волкова Л.Л., Строганов Ю.В.
            \vfill
            
            2019 г.
            
            \end{center}

    \end{titlepage}
    \setcounter{page}{2}
\tableofcontents
	
	\newpage
	
        \section*{Введение}
        
        \addcontentsline{toc}{section}{Введение}
        
        \parindent=1cm
        
        
        Целью данной работы является изучение и реализация параллельного алгоритма Винограда для умножения матриц. Необходимо сравнить зависимость времени работы алгоритма от числа параллельных потоков исполнения и размера матриц, провести сравнение стандартного и параллельного
алгоритма.
        

        \label{sec:intro}

    	\newpage
        \section{Аналитическая часть}
		\parindent=1cm
		
		В данной части будут рассмотрены теоретические основы алгоритмов.
		

        \subsection{Теоретические сведения об умножении матриц}
        
		\textbf{Матрица} – это прямоугольная таблица каких-либо элементов. Здесь и далее мы будем рассматривать только матрицы, элементами которых являются числа. Упорядоченная пара чисел (n, m), где n - количество строк в матрице, m - количество столбцов, называется размерностью матрицы, обозначается обычно m x n\cite{Beloysov}.
		
		Пусть имеются две матрицы: A и B размерами n x l и l x m соответственно.\\
		\[ \begin{bmatrix}
		a_{1,1} & a_{1,2} & ... & a_{1,l} \\
		a_{2,1} & a_{2,2} & ... & a_{2,l}\\		
		... & ... & ... & ... \\
		a_{n,1} & a_{n, 2} & ... & a_{n,l} \\
		\end{bmatrix} \]\\
				\[ \begin{bmatrix}
		b_{1,1} & b_{1,2} & ... & b_{1,m} \\
		b_{2,1} & b_{2,2} & ... & b_{2,m}\\		
		... & ... & ... & ... \\
		b_{l,1} & b_{l, 2} & ... & b_{l,m} \\
		\end{bmatrix} \]\\
		
		
		\textbf{Произведением матриц} A и B размерами n x l и l x m соответственно называется матрица C размерами n x m, каждый элемент которой вычисляется по формуле (\ref{mult}):\\
		\begin{equation} \label{mult}
		c_{i,j} = \sum\limits_{r=1}^n a_{i,r}\cdot b_{r,j}
		\end{equation}		
		\[ \begin{bmatrix}
		c_{1,1} & b_{1,2} & ... & c_{1,m} \\
		c_{2,1} & b_{2,2} & ... & c_{2,m}\\		
		... & ... & ... & ... \\
		c_{n,1} & c_{n, 2} & ... & c_{n,m} \\
		\end{bmatrix} \]\\
		
		\subsection{Алгоритм Винограда}
		
		Если посмотреть на результат умножения двух матриц, то видно,
		что каждый элемент в нем представляет собой скалярное произведение
		соответствующих строки и столбца исходных матриц. Также некоторые вычисления можно произвести заранее, что ускорит выполнение алгоритма.
		Рассмотрим два вектора V = $(v_{1}, v_{2}, v_{3}, v_{4})$ и W = $(w_{1}, w_{2}, w_{3}, w_{4})$\\
		    Их скалярное произведение находится по формуле (\ref{scal})\\
		    \begin{equation}\label{scal}
 V \cdot W=v_1 \cdot w_1 + v_2 \cdot w_2 + v_3 \cdot w_3 + v_4 \cdot w_4 
		    \end{equation}
		    
		    
         Равенство (\ref{scal}) можно переписать в виде (\ref{scal2})\\
         \begin{equation}\label{scal2}
V \cdot W=(v_1 + w_2) \cdot (v_2 + w_1) + (v_3 + w_4) \cdot (v_4 + w_3) - v_1 \cdot v_2 - v_3 \cdot v_4 - w_1 \cdot w_2 - w_3 \cdot w_4
         \end{equation}\\
        В Алгоритме Винограда используется скалярное произведение из формулы 2, в отличие от стандартного алгоритма. Алгоритм Винограда позволяет выполнить предварительную обработку матрицы и запомнить значения для каждой строки/столбца матриц.
Над предварительно обработанными элементами нам придется выполнять лишь первые два умножения и последующие пять сложений, а также
дополнительно два сложения\cite{litlink1}.\\
		
		\subsection{Параллельные вычисления}
		Параллельные вычисления — способ организации компьютерных вычислений, при котором программы разрабатываются как набор взаимодействующих вычислительных процессов, работающих параллельно (одновременно). 
		
		При использовании многопроцессорных вычислительных систем с общей памятью обычно предполагается, что имеющиеся в составе системы процессоры обладают равной производительностью, являются равноправными при доступе к общей памяти, и время доступа к памяти является одинаковым (при одновременном доступе нескольких процессоров к одному и тому же элементу памяти очередность и синхронизация доступа обеспечивается на аппаратном уровне). Многопроцессорные системы подобного типа обычно именуются симметричными мультипроцессорами (symmetric multiprocessors, SMP).\\		
	Перечисленному выше набору предположений удовлетворяют также активно развиваемые в последнее время многоядерные процессоры, в которых каждое ядро представляет практически независимо функциони рующее вычислительное устройство.
	
	Обычный подход при организации вычислений для многопроцессорных вычислительных систем с общей памятью – создание новых параллельных методов на основе обычных последовательных программ, в которых или автоматически компилятором, или непосредственно программистом выделяются участки независимых друг от друга вычислений. Возможности автоматического анализа программ для порождения параллельных вычислений достаточно ограничены, и второй подход является преобладающим. При этом для разработки параллельных программ могут применяться как новые алгоритмические языки, ориентированные на параллельное программирование, так и уже имеющиеся языки, расширенные некоторым набором операторов для параллельных вычислений.
	
	Широко используемый подход состоит и в применении тех или иных библиотек, обеспечивающих определенный программный интерфейс (application programming interface, API) для разработки параллельных программ. В рамках такого подхода наиболее известны Windows Thread API. Однако первый способ применим только для ОС семейства Microsoft Windows, а второй вариант API является достаточно трудоемким для использования и имеет низкоуровневый характер \cite{Barkalov}.
	\subsection{Параллельный алгоритм Винограда}
	Трудоемкость алгоритма Винограда имеет сложность $O(nmk)$ для умножения матриц $n1 \times m1$ на $n2 \times m2$. Чтобы улучшить алгоритм, следует распараллелить ту часть алгоритма, которая содержит 3 вложенных цикла. Помимо этого, можно объединить всю остальную часть алгоритма и ее тоже распараллелить, тем самым разбив алгоритм на два последовательно выполняющихся участка.
	
	В результирующей матрице каждая ячейка вычисляется независимо от других, поэтому, вычисляя отдельные строки разными потоками, получится не сталкиваться с проблемой "разделяемых данных" между потоками, так как каждый поток будет отвечать за свой участок итоговой матрицы.
	
	   
    \subsection{Вывод}
    В данном разделе были рассмотрены общие сведения об умножении матриц, алгоритм Винограда, способ его распараллеливания а также теоретические сведения о параллельных вычислениях.
     	\newpage
        \section{Конструкторская часть}
        
		В данной части будут рассмотрены схема алгоритма винограда и модели его распараллеливания. \\
        \subsection{Схема алгоритма Винограда}
        На рисунке \ref{v_s} приведена схема алгоритма Винограда.\\

    	\begin{figure}[h]
        	\center{\includegraphics[scale = 0.43]{v.jpg}}
        	\caption{Алгоритм Винограда}
        	\label{v_s}
        \end{figure}
        \newpage   
        \subsection{Модель организации параллельных вычислений}
        Алгоритм Винограда можно разбить условно на 4 части: 
        \begin{enumerate}
        \item вычисление вектора mulh(на Рис. 1 эта часть находится в промежутке от начала алгоритма до соеденителя А);
        \item вычисление вектора mulv (на Рис. 1 от A до B);
        \item основная часть(на Рис. 1 от A до C);
        \item дополнительные вычисления в случае нечетного количества столбцов в первой матрице(на Рис. 1 от С до конца алгоритма).
         \end{enumerate}
               
        В таком случае можно распараллелить часть 3, модель представлена на рисунке 2, квадраты на ней - этапы алгоритма, перегородки - ожидание всех потоков:\\ 
            	\begin{figure}[h]
        	\center{\includegraphics[scale = 0.43]{model1.jpg}}
        	\caption{Модель распараллеливания 1 для алгоритма Винограда}
        	\label{fig:schema_vinograd}
        \end{figure}
        
		Также можно заметить, что этап 4 является независимым от этапов 1 и 2 с точки зрения разделяемой памяти, друг с другом они также независимы. В связи с этим можно использовать модель распараллеливания, представленную на рисунке 3:\\
            
            	\begin{figure}[h]
        	\center{\includegraphics[scale = 0.43]{model2.jpg}}
        	\caption{Модель распараллеливания 2 для алгоритма Винограда}
        	\label{fig:schema_vinograd}
        \end{figure}		
		
\subsection{Вывод}
		В данном разделе была рассмотрена схема алгоритма Винограда и модели для его распараллеливания - модель, распараллеливающая только тройной цикл и модель, распараллеливающая тройной цикл и все кроме него.\\
        
    	\newpage
        \section{Технологическая часть}
        
        В данном разделе будут приведены листинги алгоритма Винограда и его вариантов с параллельными вычислениями на языке c++\\
        \subsection{Требования к программному обеспечению}
        Входные данные - матрица1, матрица2, их размеры.
        Выходные данные - произведение матриц.
          \begin{figure}[h]
        	\center{\includegraphics[scale = 0.45]{idef01.jpg}}
        	\caption{IDEF0-диаграмма, описывающая алгоритм умножения матриц}
        	\label{fig:schema_vinograd_optimized}
        \end{figure} \\
		\subsection{Средства реализации}
		Программа была написана на языке С++\cite{c++}, так как этот язык хорошо сбалансирован с точки зрения быстродействия и предоставляемого функционала, в качестве среды был использован QTCreator\cite{qtc}, так как он бесплатный и достаточно удобный для настройки сборки и программирования в объектно-ориентированном стиле. Для параллельных вычислений использовалась библиотека thread\cite{thread}, для замеров времени - библиотека chrono\cite{chrono}.\\

Наблюдатель joinable проверяет потенциальную возможность работы потока в параллельном контексте.
Операция join ожидает завершения потока\cite{multik}.\\
        \subsection{Листинг кода}
        В листингах 1-7 приведены все рассматриваемые в рамках данной лабораторной работы алгоритмы, написанные на языке С++.
        \newpage
		\begin{lstlisting}[label=some-code,caption=Алгоритм Винограда]
		Matrix Vinograd(Matrix& matr1, Matrix& matr2)
		{
			int n = matr1.Matrix::GetN();
			int m = matr2.Matrix::GetM();
			int m1 = matr1.Matrix::GetM();
			double *mulh = new double[n];
			double *mulv = new double[m];

			Matrix res = Matrix(n, m);

			for (int i = 0; i < n; i++)
				for (int j = 0; j < m1/2; j++)
					mulh[i] = mulh[i] + matr1[i][2*j] * matr1[i][2*j + 1];

			for (int i = 0; i < m; i++)
				for (int j = 0; j < m1/2; j++)
					mulv[i] = mulv[i] + matr2[2*j][i] * matr2[2*j + 1][i];

			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < m; j++)
				{
					res[i][j] = - mulh[i] - mulv[j];
					for (int k = 0; k < m1/2; k++)
						res[i][j] = res[i][j] + (matr1[i][2*k]+matr2[2*k+1][j])*(matr1[i][2*k+1]+matr2[2*k][j]);
				}
			}

			if (m1 % 2)
			{
				for(int i = 0; i < n; i++)
					for(int j = 0; j < m; j++)
						res[i][j] = res[i][j] + matr1[i][m1 - 1] * matr2[m1 - 1][j];
			}
			delete[] mulh;
			delete[] mulv;
			return res;
		}
		\end{lstlisting}
		
		На листинге 1 мы видим, что первой части алгоритма соответствует блок кода на 11-13 строках, второй части - блок кода на 15-17 строках, третьей - блок кода на 19-27 строках, четвертой - на 29-34 строках.
		
		\begin{lstlisting}[label=some-code,caption=Этап 3(тройной цикл) в алгоритме Винограда]
		void func_thread(Matrix &matr1, Matrix &matr2, Matrix &res,  double* mulh,  double* mulv, int num, int count)
		{
			for(int i = num; i < matr1.Matrix::GetN(); i += count)
			{
				for(int j = 0; j < matr2.Matrix::GetM(); j++)
				{
					res[i][j] = res[i][j] - mulh[i] - mulv[j];
					for(int k = 0; k < matr1.Matrix::GetM() / 2; k++)
					{
						res[i][j] = res[i][j] + (matr1[i][2*k] + matr2[2*k+1][j]) * (matr1[i][2*k + 1] + matr2[2*k][j]);
					}
				}
			}
		}
		\end{lstlisting}

	\newpage
		На листинге 3 представлен алгоритм Винограда по модели 2, рассмотренной в разделе 2.2 .
		\begin{lstlisting}[label=some-code,caption=Алгоритм Винограда по модели 1]
		Matrix Vinograd_Parallell1(Matrix& matr1, Matrix& matr2, int count)
		{
			int n = matr1.Matrix::GetN();
			int m = matr2.Matrix::GetM();
			int m1 = matr1.Matrix::GetM();
			double *mulh = new double[n];
			double *mulv = new double[m];

			Matrix res = Matrix(n, m);

			for (int i = 0; i < n; i++)
				for (int j = 0; j < m1/2; j++)
					mulh[i] = mulh[i] + matr1[i][2*j] * matr1[i][2*j + 1];

			for (int i = 0; i < m; i++)
				for (int j = 0; j < m1/2; j++)
					mulv[i] = mulv[i] + matr2[2*j][i] * matr2[2*j + 1][i];

			std::thread threads[count];

			for(int i = 0; i < count; i++)
				threads[i] = std::thread(func_thread, std::ref(matr1), std::ref(matr1), std::ref(res), mulh, mulv, i, count);

			for(int i = 0; i < count; i++)
				if(threads[i].joinable())
					threads[i].join();

			if (m1 % 2)
				for(int i = 0; i < n; i++)
					for(int j = 0; j < m; j++)
						res[i][j] = res[i][j] + matr1[i][m1 - 1] * matr2[m1 - 1][j];
			delete[] mulh;
			delete[] mulv;
			return res;
		}
		\end{lstlisting}
		
		\begin{lstlisting}[label=some-code,caption=Этап 1(вычисление mulh) в алгоритме Винограда]
		void Get_Mulh(Matrix& matr1, double *mulh, int i, int count)
		{
			int n = matr1.Matrix::GetN();
			int m1 = matr1.Matrix::GetM();
			for (int i = 0; i < n; i += count)
				for (int j = 0; j < m1/2; j++)
					mulh[i] = mulh[i] + matr1[i][2*j] * matr1[i][2*j + 1];
		}
		\end{lstlisting}

		\begin{lstlisting}[label=some-code,caption=Этап 2(вычисление mulv) в алгоритме Винограда]
		void Get_Mulv(Matrix& matr1, Matrix& matr2, double *mulv, int i, int count)
		{
			int m = matr2.Matrix::GetM();
			int m1 = matr1.Matrix::GetM();

			for (; i < m; i += count)
				for (int j = 0; j < m1/2; j+)
					mulv[i] = mulv[i] + matr2[2*j][i] * matr2[2*j + 1][i];
		}
		\end{lstlisting}
		\newpage
		\begin{lstlisting}[label=some-code,caption=Этап 4(дополнительные вычисления) в алгоритме Винограда]
		void func_thread2(Matrix& matr1, Matrix& matr2, Matrix& res, int i, int count)
		{
			int n = matr1.Matrix::GetN();
			int m = matr2.Matrix::GetM();
			int m1 = matr1.Matrix::GetM();

			for(; i < n; i += count)
				for(int j = 0; j < m; j++)
					res[i][j] = res[i][j] + matr1[i][m1 - 1] * matr2[m1 - 1][j];
		}
		\end{lstlisting}
		
		На листинге 7 представлен алгоритм Винограда по модели 2, рассмотренной в разделе 2.2 .
		\begin{lstlisting}[label=some-code,caption=Алгоритм Винограда по модели 2]
		Matrix Vinograd_Parallell2(Matrix& matr1, Matrix& matr2, int count)
		{
			int n = matr1.Matrix::GetN();
			int m = matr2.Matrix::GetM();
			int m1 = matr1.Matrix::GetM();
			double * mulh = new double[n];
			double * mulv = new double[m];
			for (int i = 0; i < n; i++)
				mulh[i] = 0;
			for (int i = 0; i < m; i++)
				mulv[i] = 0;

			Matrix res = Matrix(n, m);

			if (m1 % 2)
			{

				int count1 = (count + (count % 4)? (4 - count % 4) : 0)/4;
				std::thread t1[count1];
				std::thread t2[count1];
				std::thread t3[count1*2];
				for(int i = 0; i < count1; i++)
				{
					t1[i] = std::thread(Get_Mulh, std::ref(matr1), mulh, i, count1);
					t2[i] = std::thread(Get_Mulv, std::ref(matr1), std::ref(matr2), mulv, i, count1);
					if(t1[i].joinable())
						t1[i].join();
					if(t2[i].joinable())
						t2[i].join();
				}
				for(int i = 0; i < count1 * 2; i++)
				{
					t3[i] = std::thread(func_thread2, std::ref(matr1), std::ref(matr2), std::ref(res), i, count1*2);
					if(t3[i].joinable())
						t3[i].join();
				}
			}
			else
			{
				int count1 = (count + ((count % 2)? 1 : 0))/2;
				std::thread t1[count1];
				std::thread t2[count1];

				for(int i = 0; i < count1; i++)
				{
					t1[i] = std::thread(Get_Mulh, std::ref(matr1), mulh, i, count1);
					t2[i] = std::thread(Get_Mulv, std::ref(matr1), std::ref(matr2), mulv, i, count1);
					if(t1[i].joinable())
						t1[i].join();
					if(t2[i].joinable())
						t2[i].join();
				}
			}
			std::thread threads[count];

			for(int i = 0; i < count; i++)
				threads[i] = std::thread(func_thread, std::ref(matr1), std::ref(matr1), std::ref(res), &mulh[0], &mulv[0], i, count);

			for(int i = 0; i < count; i++)
				if(threads[i].joinable())
					threads[i].join();
			delete[] mulh;
			delete[] mulv;
    		return res;
		}
		\end{lstlisting}
   \subsection{Вывод} 
   		В данном разделе были рассмотрены листинг алгоритма Винограда, а также листинги моделей распараллеливания этого алгоритма, рассмотренных в разделе 2.2.

    
       	\newpage
       	
        \section{Экспериментальная часть}
		В данном разделе будет экспериментально найдено быстродействие алгоритма Винограда в сравнении с его распараллеленными по модели 1 и модели 2 версиями.
		\subsection{Постановка эксперимента}
		\parindent=1cm
		Требуется провести замеры времени для работы алгоритмов при размерах матрицы от 100 до 1000 c шагом 100 и при размерах матрицы от 101 до 1001 с шагом 100, так как в Алгоритме Винограда при нечетных размерах матрицы добавляются дополнительные вычисления, это должно сыграть роль в модели распараллеливания 2, где эти вычисления происходят одновременно с нахождением векторов mulh и mulv.\\
		
		
		Тестовый компьютер:
		\begin{itemize}
			\item ЦПУ -INTEL® PENTIUM® N5000 (4 физических ядра, 4 логических ядра, базовая тактовая частота - 1.1 ГГц, максимальная - 2.7 ГГц, в большинстве случаев тактовая частота $\approx$ 2.3 ГГц)\cite{intel}
			\item ОЗУ - 8 ГБ 2400 МГц
			\item ОС - Ubuntu Mate 18.04
		\end{itemize}
		\subsection{Результаты эксперимента}
		На рисунках \ref{0-1c} и \ref{0-1n} представлены замеры времени для обычного алгоритма Винограда и распараллеленного на 2, 4, 8, 16 потоков по модели 1. На рисунках \ref{1-2c} и \ref{1-2n} представлены замеры времени для алгоритма Винограда, распараллеленного на 2, 4, 8, 16 потоков алгоритма винограда по моделям 1 и 2.
		 
		          \begin{figure}[h]
        	\center{\includegraphics[scale = 0.5]{chet_2.jpg}}
        	\caption{Сравнение быстродействия алгоритма Винограда и алгоритма Винограда, распараллеленного по модели 1 на четных размерах матрицы}
        	\label{0-1c}
        \end{figure}  
        \newpage      
        \begin{figure}[h]
        	\center{\includegraphics[scale = 0.5]{nechet_1.jpg}}
        	\caption{Сравнение быстродействия алгоритма Винограда и алгоритма Винограда, распараллеленного по модели 1 на нечетных размерах матрицы}
        	\label{0-1n}
        \end{figure}   
             
        \begin{figure}[h]
        	\center{\includegraphics[scale = 0.4]{1-2c.jpg}}
        	\caption{Сравнение быстродействия алгоритма Винограда, распараллеленного по моделям 1 и 2 на четных размерах матрицы}
        	\label{1-2c}
        \end{figure}   
        \newpage       
        \begin{figure}[h]
        	\center{\includegraphics[scale = 0.6]{nechet2.jpg}}
        	\caption{Сравнение быстродействия алгоритма Винограда, распараллеленного по моделям 1 и 2 на нечетных размерах матрицы}
        	\label{1-2n}
        \end{figure}
        \newpage  
        \subsection{Анализ полученых результатов эксперимента}
        На рисунках \ref{0-1c} и \ref{0-1n} мы видим, что наибольший прирост производительности происходит при переходе от обычного алгоритма Винограда к двухпоточному(разница растет от 52\% до 72\% при возрастающей матрице), меньше, но все же значительный прирост алгоритм получает при переходе от 2 к 4 потокам(от 23\% до 51\%). При дальнейшем увеличении числа потоков программы при матрицах размером 400х400 производительность растет не сильно(в районе 0.5\%), в то время как на более маленьких матрицах наоборот падает(на 8\% при переходе от 4 к 8 потокам и от 8 к 16). Следует заметить, что компьютер, на котором производилось тестирование, имеет 4 логических ядра, то есть он физически не может обрабатывать количество потоков большее, чем 4, что и вызвало столь малый прирост при переходе от 4 к 8 и 16 потокам. Что касается стандартного алгоритма Винограда и однопоточного, видно, что однопоточная реализация всегда отстает(хотя разница уменьшается от 14\% при матрицах 100х100 до 5\% при матрицах 1000х1000),это обусловлено работой библиотеки pthreads для обеспечения потоков на уровне пользователя. По грисункам \ref{0-1c} и \ref{0-1n} мы делаем вывод, что нет смысла параллелить алгоритм Винограда на число потоков большее, чем логических ядер процессора
        
        По рисункам \ref{1-2c} и \ref{1-2n} можно заметить, что при равных количествах алгоритм Винограда, распараллеленный по моделям 1 и 2 практически не отличается, при размерностях матрийц (в районе от 0.1\% до 3\% в пользу то одной модели, то другой), из чего мы делаем вывод, что в алгоритме достаточно распараллелить только самую трудоемкую часть, чтобы получить достаточный прирост производительности.
        \newpage 
	\subsection{Вывод}
	В данном разделе было рассмотрено сравнение быстродействия алгоритма Винограда и его распараллеленных версий по модели 1 и 2. По результатам тестирования оказалось, что наибольший прирост наблюдается при переходе от обычного алгоритма Винограда к четырехпоточномой версии модели, в которой распараллелен только тройной цикл.

    	\newpage
        \section*{Заключение}
        \addcontentsline{toc}{section}{Заключение}
        
        В ходе лабораторной работы были исследованы методы распараллеливания алгоритма Винограда и их эффективность на практике а так же получены навыки в области параллельных вычислений. По результатам тестирования эффективности двух моделей распараллеливания алгоритма Винограда были сделаны следующие выводы.
        \begin{itemize}
        \item Нет смысла параллелить алгоритмы на количество потоков больше, чем число логических ядер процессора, однако, если программное обеспечение разрабатывается для широкого круга компьютеров, не стоит забывать, что существуют процессоры с 16 и больше потоками, на которых чем сильнее распараллелена программа, тем лучше.
        \item В алгоритме Винограда достаточно распараллелить только самую трудоемкую часть алгоритма, параллеливание остальных участков не дает прироста больше 3\%, а иногда и вовсе вредит.
        \end{itemize}
        


    \begin{center}
    	\newpage
        \addcontentsline{toc}{section}{Список литературы}
        
        \begin{thebibliography}{}
	\bibitem{Beloysov} И. В. Белоусов(2006), Матрицы и определители, учебное пособие по линейной алгебре, с. 1 - 16
    \bibitem{litlink1}  Дж. Макконнелл. Анализ алгоритмов. Активный обучающий подход.-М.:Техносфера, 2009.
	\bibitem{Barkalov} Константин Баркалов, Владимир Воеводин, Виктор Гергель. Intel Parallel Programming [Электронный ресурс], - режим доступа https://www.intuit.ru/studies/courses/4447/983/lecture/14925	
    \bibitem{habr} Pthreads: Потоки в русле POSIX. [Электронный ресурс], - режим доступа https://habr.com/ru/post/326138/
	\bibitem{multik} Multithreading in C++ [Электронный ресурс], - режим доступа https://www.geeksforgeeks.org/multithreading-in-cpp/
	\bibitem{intel} Спецификации процессора INTEL PENTIUM 5000 [Электронный ресурс] - режим доступа https://www.intel.ru/content/www/ru/ru/products/processors/pentium/n5000.html
	\bibitem{c++} Документация по языку C++ [Электронный ресурс] - режим доступа https://devdocs.io/cpp/
	\bibitem{qtc} Документация по среде QTCreator [Электронный ресурс] - режим доступа http://doc.crossplatform.ru/qtcreator/1.2.1/	
	\bibitem{chrono} Документация по библиотеке chrono [Электронный ресурс] - режим доступа https://docs.microsoft.com/ru-ru/cpp/standard-library/chrono?view=vs-2019
	\bibitem{thread} Документация по библиотеке chrono [Электронный ресурс] - режим доступа https://docs.microsoft.com/ru-ru/cpp/standard-library/chrono?view=vs-2019
	\end{thebibliography}
	\bibliographystyle{alpha}
	\bibliography{mybib}
	
        
    \end{center}        
\end{document}
