\documentclass[a4paper, 14pt]{article}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{listings}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
    decorations.pathreplacing,decorations.pathmorphing,shapes,%
    matrix,shapes.symbols}

\usepackage{titlesec}
\titleformat*{\section}{\LARGE\bfseries\centering}
\titleformat*{\subsection}{\Large\bfseries\centering}
\titleformat*{\subsubsection}{\large\bfseries}
\titleformat*{\paragraph}{\large\bfseries}
\titleformat*{\subparagraph}{\large\bfseries}
\lstset{ %
language=c++,                 % выбор языка для подсветки (здесь это С)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\#*}{*)}   % если нужно добавить комментарии в коде
}

\usepackage{geometry}
\geometry{left=2cm}
\geometry{right=1.5cm}
\geometry{top=1cm}
\geometry{bottom=2cm}

\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}
\usepackage{graphicx}

\begin{document}

    \begin{titlepage}

        \begin{center}
            \large
            Государственное образовательное учреждение высшего профессионального образования\\
            “Московский государственный технический университет имени Н.Э.Баумана”
            \vspace{3cm}
            
            \textsc{Дисциплина: Анализ алгоритмов}
            \vspace{0.5cm}
                
            \textsc{Лабораторная работа 7}
            \vspace{1.5cm}
            
            {\LARGE Поиск подстроки в строке\\}
            \vspace{1.5cm}
            Студент группы ИУ7-55,\\   
            Аминов Т.С.\\
            Преподаватели: Волкова Л.Л., Строганов Ю.В.
            \vfill
            
            2019 г.
            
            \end{center}

    \end{titlepage}
    \setcounter{page}{2}
\tableofcontents
	
	\newpage
	
        \section*{Введение}
        
        \addcontentsline{toc}{section}{Введение}
        
        \parindent=1cm
        
        
        Целью данной лабораторной работы является изучение алгоритмов для поиска подстроки в строке: алгоритма Кнута-Морриса-Пратта и алгоритма Бойера-Мура.
        
		Задачами данной лабораторной работы являются: реализация обоих алгоритмов на одном из языков программирования и рассмотрение работы каждого из них на примере.
        \label{sec:intro}

    	\newpage
        \section{Аналитическая часть}
		\parindent=1cm
		
		В данной части будут рассмотрены теоретические основы задачи поиска подстроки в строке и алгоритмов Кнута-Морриса-Пратта и Бойера-Мура, ее решающих. 
		
\subsection{Постановка задачи}\label{zad} 
	Имеются две конечные последовательности символов \cite{matan} - substring и text. Требуется узнать, включена ли последовательность substring в text и если да, то определить место первого из включений. Здесь и далее вместо термина "конечная последовательность символов" будет употреблятся слово "строка".
	
        \subsection{Простой алгоритм}
        Простой алгоритм нахождения подстроки в строке заключается в том, что в строке text ищется сначала символ, совпадающий с первым символом строки substring, и далее последующие символы строки text проверяются на совпадение с последующими из substring, и если не все символы совпали, снова ведется поиск на совпадение с первой буквой, и так далее, пока не найдется полное совпадение. 
        
        Из алгоритма ясно, что основная операция — сравнение символов, и именно число сравнений и следует подсчитывать. В наихудшем случае при каждом проходе совпадают все символы за исключением последне-го. Это может произойти по одному разу на каждый символ текста. Если длина подстроки равна 5, а длина текста равна Т, то, в наихудшем случае число сравнений будет равно S(T — S + I) \cite{pstr}.

		\subsection{Конечные автоматы}
 		Конечные автоматы используются для решения задачи о том, принадлежит ли данное слово данному языку  \cite{diskr}. Конечный автомат представляет собой простое устройство, описываемое текущим состоянием и функцией перехода. Функция перехода формирует новое состояние автомата по текущему состоянию и значению очередного входного символа. Некоторые состояния считаются принимающими, и если после окончания ввода автомат оказывается в принимающем состоянии, то входное слово считается принятым. Конечные автоматы широко используются в алгоритмах, связанных со строками, например, при шифровании текста Машиной Тьюринга\cite{mt}.
 		
Конечный автомат, настроенный на данный образец, можно использовать для сравнения с образцом; если автомат переходит в принимаю-
щее состояние, то это означает, что образец найден в тексте. Использование конечных автоматов очень эффективно, поскольку такой автомат обрабатывает каждый символ однократно. Поэтому поиск образца с помощью конечного автомата требует не более Т сравнений. Теперь встает задача создания конечного детерминированного автомата, отвечающего данной подстроке. Это непросто; существующие алгоритмы работают долго. Поэтому конечные автоматы и не дают общепринятого хорошего решения задачи сравнения с образцом.
		\subsection{Алгоритм Кнута-Морриса-Пратта}
		При построении конечного автомата для поиска подстроки в тексте легко построить переходы из начального состояния в конечное принимающее состояние: эти переходы помечены символами подстроки. Проблема возникает при попытке добавить другие символы,
которые не переводят в конечное состояние.

	Алгоритм Кнута-Морриса-Пратта основан на принципе конечного автомата, однако он использует более простой метод обработки неподходящих символов. В этом алгоритме состояния помечаются символами, совпадение с которыми должно в данный момент произойти. Из каждого состояния имеется два перехода: один соответствует успешному сравнению, другой — несовпадению. Успешное сравнение переводит нас в следующий узел автомата, а в случае несовпадения мы попадаем в предыдущий узел, отвечающий образцу.
	
	При всяком переходе по успешному сравнению в конечном автомате Кнута-Морриса—Пратта происходит выборка нового символа из текста. Переходы, отвечающие неудачному сравнению, не приводят к выборке нового символа; вместо этого они повторно используют последний выбранный символ. Если мы перешли в конечное состояние, то это означает, что искомая подстрока найдена \cite{analg}.
		\subsection{Алгоритм Бойера-Мура}
		В отличие от алгоритмов, обсуждавшихся выше, алгоритм Бойера-Мура осуществляет сравнение с образцом справа налево, а не слева направо. Исследуя искомый образец, можно осуществлять более эффективные прыжки в тексте при обнаружении несовпадения.
		
		Алгоритм Бойера-Мура обрабатывает образец двумя способами. Во-первых, мы можем вычислить величину возможного сдвига при несовпадении очередного символа. Во-вторых, мы вычислим величину прыжка, выделив в конце образца последовательности символов, уже появлявшиеся раньше.
	
	Мы дали общее описание того, как будут использоваться массивы сдвигов и прыжков. Массив сдвигов содержит величины, на которые может быть сдвинут образец при несовпадении очередного символа. В массиве прыжков содержатся величины, на которые можно сдвинуть образец, чтобы совместить ранее совпавшие символы с вновь совпадающими символами строки. При несовпадении очередного символа образца с очередным символом текста может осуществиться несколько возможностей. Сдвиг в массиве сдвигов может превышать сдвиг в массиве прыжков, а может быть и наоборот. Если элемент массива сдвигов больше, то это означает, что несовпадающий символ оказывается «ближе» к началу, чем повторно появляющиеся завершающие символы строки. Если элемент массива прыжков больше, то повторное появление завершающих символов строки начинается ближе к началу образца, чем несовпадающий символ. В обоих случаях нам следует пользоваться большим из двух сдвигов, поскольку меньший сдвиг неизбежно опять приводит к несовпадению из-за того, что мы знаем о втором значении.
    \subsection{Вывод}
	В данном разделе были рассмотрены алгоритмы поиска подстроки в строке, такие как: простой алгоритм, алгоритм Кнута-Морриса-Пратта и алгоритм Бойера-Мура. Последний является наиболее выгодным с точки зрения количества сравнений, так как сдвиг при несовпадении при его работе максимальный среди перечисленных алгоритмов. 
		\newpage
        \section{Конструкторская часть}
        В данном разделе будет рассмотрены схемы алгоритмов и рассмотрена их работа на примере.
        \subsection{Схемы алгоритма Кнута-Морриса-Пратта}
        На рисунке \ref{fig:ant} приведена схема нахождения подстроки в строке в алгоритме Кнута-Морриса-Пратта.\\

       \begin{figure}[h]
        	\center{\includegraphics[scale = 0.5]{k-k-p-auto.jpg}}
        	\caption{Схема нахождения подстроки в строке в алгоритме Кнута-Морриса-Пратта}
        	\label{fig:ant}
        \end{figure}
        \newpage  
        На рисунке \ref{fig:f_p} приведена схема cоставления массива fail в алгоритме Кнута-Морриса-Пратта.\\

    	\begin{figure}[h]
        	\center{\includegraphics[scale = 0.5]{k-k-p-auto155.jpg}}
        	\caption{Cхема cоставления массива fail в алгоритме Кнута-Морриса-Пратта}
        	\label{fig:f_p}
        \end{figure}
        \newpage   
        \subsection{Схемы алгоритма Бойера-Мура}\label{vstad}
        На рисунке \ref{fig:shift} приведена схема нахождения подстроки в строке в алгоритме Бойера-Мура.\\
       \begin{figure}[h]
        	\center{\includegraphics[scale = 0.5]{b-m.jpg}}
        	\caption{Схема нахождения подстроки в строке в алгоритме Бойера-Мура}
        	\label{fig:shift}
        \end{figure} 
        \newpage   

        На рисунке \ref{fig:shift} приведена схема нахождения массива сдвигов в алгоритме Бойера-Мура.\\
       \begin{figure}[h]
        	\center{\includegraphics[scale = 0.6]{b-m-arr-sh.jpg}}
        	\caption{Схема нахождения массива сдвигов в алгоритме Бойера-Мура}
        	\label{fig:shift}
        \end{figure} 
        \newpage   
       
        На рисунке \ref{fig:jmp} приведена схема нахождения массива прыжков в алгоритме Бойера-Мура.\\
       \begin{figure}[h]
        	\center{\includegraphics[scale = 0.6]{b-m-arr-jmp.jpg}}
        	\caption{Схема нахождения массива прыжков в алгоритме Бойера-Мура}
        	\label{fig:jmp}
        \end{figure} 
        \newpage               
		\subsection{Пример работы алгоритмов}
		Рассмотрим работу алгоритмов на примере. Подстроку примем равной "test", а строку - "zestesctestpppp".
		
		\begin{center}
				\textbf{ Алгоритм Кнута-Морриса-Пратта}
		\end{center}
		Для строки "test" конечный автомат будет выглядеть так, как показано на рисунке \ref{fig:ka}.
       \begin{figure}[h]
        	\center{\includegraphics[scale = 0.6]{k-m-p-pr.jpg}}
        	\caption{Конечный автомат в алгоритме Кнута-Морриса-Пратта для строки "test"}
        	\label{fig:ka}
        \end{figure} 
        
        Содержание массива fail: {0, 1, 1, 1}
        
        Пошаговая работа алгоритма показана в таблице 1.
	
		\begin{center}
	Таблица 1. Пошаговая работа алгоритма Кнута-Морриса-Пратта.\\

	\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | }
	\hline
	z&e&s&t&e&s&c&t&e&s&t&p&p&p&p \\
	\hline
	\textcolor{red}{t}&e&s&t&&&&&&&&&&& \\
	&\textcolor{red}{t}&e&s&t&&&&&&&&&& \\
	&&\textcolor{red}{t}&e&s&t&&&&&&&&& \\
	&&&\textcolor{green}{t}&\textcolor{green}{e}&\textcolor{green}{s}&\textcolor{red}{t}&&&&&&&& \\
	&&&&&&\textcolor{red}{t}&e&s&t&&&&& \\
	&&&&&&&\textcolor{green}{t}&\textcolor{green}{e}&\textcolor{green}{s}&\textcolor{green}{t}&&&& \\
	\hline

	
	\end{tabular}
		\end{center}
		
				\begin{center}
				\textbf{Алгоритм Бойера-Мура}
		\end{center}
		
		Рассмотрим сначала составление массивов shift и jump.
		
		\textbf{Нахождение массива сдвигов.}	\\	
		
		После первого цикла все элементы (в данном случае их 256, так как за алфавит была принята таблица ASCII) были инициализированы значением 4 (длина подстроки).
		После второго цикла свое значение изменят следующие элементы массива: shift['e'] = 0, shift['s'] = 1, shift['t'] = 2.
		
		\textbf{Нахождение массива прыжков.}\\
		
		После первого цикла его значения будут такими: 7, 6, 5, 4.
		
		После второго цикла: 7, 6, 5, 1.
		
		Массив link после второго цикла: 0, 3, 3, 4.
		
		Массив jump после третьего цикла: 6, 5, 4, 1.
		
		Массив jump после четвертого цикла: 6, 5, 4, 1.
		
		Теперь рассмотрим работу непосредственно поиска подстроки в строке. Пошаговый поиск показан в таблице 2:

		\begin{center}
	Таблица 2. Пошаговая работа алгоритма Бойера-Мура.\\

	\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | }
	\hline
	z&e&s&t&e&s&c&t&e&s&t&p&p&p&p \\
	\hline
	\textcolor{red}{t}&\textcolor{green}{e}&\textcolor{green}{s}&\textcolor{green}{t}&&&&&&&&&&& \\
	&&&t&e&s&\textcolor{red}{t}&&&&&&&& \\
	&&&&&&&\textcolor{green}{t}&\textcolor{green}{e}&\textcolor{green}{s}&\textcolor{green}{t}&&&& \\
	
	\hline

	
	\end{tabular}
		\end{center}
		
\subsection{Вывод}
	В данном разделе были рассмотрены схемы алгоритмов, а также разобрана работа каждого из них на примере. На примере с подстрокой "test", а строкой - "zestesctestpppp" алгоритму Кнута-Морриса-Пратта потребовалось 12 сравнений, а алгоритму Бойера-Мура - 9, что подтверждает то, что по количеству сравнений алгоритм Бойера-Мура более эффективный.
	\newpage
        \section{Технологическая часть}
        В данной части будут рассмотрены средства для реализации алгоритмов.
        \subsection{Требования к программному обеспечению}
        Входные данные - текст, подстрока.
        
        Выходные данные - индекс первого вхождения.
        
        На рисунке \ref{fig:schema_vinograd_optimized} дана функциональная схема решения задачи поиска подстроки в строке в нотации IDEF0.
          \begin{figure}[h]
        	\center{\includegraphics[scale = 0.6]{idef0.jpg}}
        	\caption{Функциональная схема решения задачи поиска подстроки в строке}
        	\label{fig:schema_vinograd_optimized}
        \end{figure} \\
		\subsection{Средства реализации}
		В качестве языка программирования был выбран c++ \cite{c++} из-за большого числа библиотек, в качестве фреймворка для разработки был выбран QT \cite{qt} по тем же причинам, среда разработки - QTCreator \cite{qtc}.
        \subsection{Листинг кода}
        
		На листинге \ref{lstvd} представлена функция нахождения подстроки в строке по алгоритму Кнута-Морриса-Пратта.
  
        \lstinputlisting[language=c++, caption=Функция нахождения подстроки в строке по алгоритму Кнута-Морриса-Пратта, label=lstvd, firstline = 6, lastline = 23]{k_m_p.LST}
\newpage
		На листинге \ref{lstint} представлена функция нахождения массива fail в алгоритме Кнута-Морриса-Пратта.
		
        \lstinputlisting[language=c++, caption=Функция нахождения массива fail в алгоритме Кнута-Морриса-Пратта, label=lstint, firstline = 25, lastline = 38]{k_m_p.LST}

		На листинге \ref{lstvin} представлена функция нахождения подстроки в строке по алгоритму Бойера-Мура.
      
        \lstinputlisting[language=c++, caption=Функция нахождения подстроки в строке по алгоритму Бойера-Мура, label=lstvin, firstline = 6, lastline = 28]{b_m.LST}
        
		На листинге \ref{lstbms} представлена функция нахождения массива shift в алгоритме Бойера-Мура.
      
        \lstinputlisting[language=c++, caption=Функция нахождения массива shift в алгоритме Бойера-Мура, label=lstbms, firstline = 30, lastline = 40]{b_m.LST}
\newpage

		На листинге \ref{lstbmj} представлена функция нахождения массива jump в алгоритме Бойера-Мура.
      
        \lstinputlisting[language=c++, caption=Функция нахождения массива jump в алгоритме Бойера-Мура, label=lstbmj, firstline = 42, lastline = 77]{b_m.LST}
        
        На листингах \ref{lstbmob} и \ref{lstkmpob} представлены "оберточные" функции обоих алгоритмов, нужные для того, чтобы не разбивать алгоритм на 2 и 3 вызова различных функций соответственно.

        \lstinputlisting[language=c++, caption="Оберточная" функция алгоритма Кнута-Морриса-Пратта, label=lstbmob, firstline = 1, lastline = 4]{k_m_p.LST}
      
        \lstinputlisting[language=c++, caption="Оберточная" функция алгоритма Бойера-Мура, label=lstkmpob, firstline = 1, lastline = 4]{b_m.LST}
        

	\subsection{Тестирование на правильность работы}
	Было проведено тестирование обоих алгоритмов на правильность работы для 9 различных пар строк text и substring. Результаты тестирования приведены в таблице 3. Поля таблицы 3: substring - подстрока, text - строк, К-М-П - результат работы алгоритма Кнута-Морриса-Пратта, Б-М - результат работы алгоритма Бойера-Мура.\
	\newpage
	\begin{center}
	Таблица 3. Результаты тестирования алгоритмов.\\

	\begin{tabular}{| c | c | r | r | r |}
	\hline
	substring & text & К-М-П & Б-М & ожидаемый  результат\\ \hline
	aab & aaaaaaaab & 6 & 6 & 6	\\
	test & testestesttes & 0 & 0 & 0\\
	37 & 37373737 & 0 & 0 & 0\\
	cc & aba & -1 & -1 & -1\\
	they & thereztheyzare & 6 & 6 & 6\\
	ser & sergey & 0 & 0 & 0\\
	gey & sergey & 3 & 3 & 3\\
	asdb & asdasdasdasd & -1 & -1 & -1\\
	\hline
	
	\end{tabular}
		\end{center}
	Во всех рассматриваемых в таблице 3 случаях результаты работы алгоритмов совпали с ожидаемыми, что подтвердило их правильность. 
   \subsection{Вывод} 
   В данном разделе были представлены реализации алгоритмов Кнута-Морриса-Пратта и Бойера-Мура, и подтверждена их правильность (реализаций).
   \newpage
       	

        \section*{Заключение}
        \addcontentsline{toc}{section}{Заключение}
		В ходе данной лабораторной работы были изучены алгоритмы Кнута-Морриса-Пратта и Бойера-Мура для поиска подстроки в строке, рассмотрена работа каждого из них на примере, и представлена реализация обоих алгоритмов на языке c++. Правильность реализации была проверена с помощью тестирования на заготовленных данных.
    \begin{center}
    	\newpage
        \addcontentsline{toc}{section}{Список литературы}
        
        \begin{thebibliography}{}
	\bibitem{diskr} Белоусов А.И., Ткачев С.Б(2006). Дискретная математика, 4-е издание.
	\bibitem{matan}  Морозова В.Д, Введение в анализ(1996).
	\bibitem{pstr} Солдатова Г.П., Татаринов А.А., Болдырихин Н.В., Основные алгоритмы поиска подстроки в строке. 
	\bibitem{mt} Чернушко М. М. Применение машины Тьюринга для реализации алгоритмов шифрования [Текст] // Технические науки: теория и практика: материалы II Междунар. науч. конф. (г. Чита, январь 2014 г.). — Чита: Издательство Молодой ученый, 2014. — С. 19-22. — URL https://moluch.ru/conf/tech/archive/88/4317/ (дата обращения: 11.12.2019).
	\bibitem{analg}  Дж. Макконнелл. Анализ алгоритмов. Активный обучающий подход.-М.:Техносфера, 2009.
	\bibitem{c++} Документация по языку C++ [Электронный ресурс] - режим доступа https://devdocs.io/cpp/
	\bibitem{qtc} Документация по среде QTCreator [Электронный ресурс] - режим доступа http://doc.crossplatform.ru/qtcreator/1.2.1/	
	\bibitem{qt} Документация по фреймворку QT [Электронный ресурс] - https://doc.qt.io/
	\end{thebibliography}
	\bibliographystyle{alpha}
	\bibliography{mybib}
	
        
    \end{center}        
\end{document}
